# Requirements: Tauri i18n Integration

*Generated from conversation on 2025-11-27*

## Objective
Integrate internationalization into the Tauri 2.0 React app using `tauri-plugin-i18n` with system locale detection via `tauri-plugin-locale`, enabling runtime language switching and persistent user preference with English as default/fallback.

## Core Requirements

### Must Have (High Priority)
- [HIGH] Detect system locale on startup via `tauri-plugin-locale`; default and fallback to English when detection fails or locale unsupported.
- [HIGH] Integrate `tauri-plugin-i18n` for UI translations in React (TypeScript + Vite), with locale resources stored under `src/locales/<lang>.json` (nested keys).
- [HIGH] Provide runtime language switcher in Settings; switching applies immediately without app restart and persists to existing config file (same storage as dark mode).
- [HIGH] Support locales at launch: en (default/fallback), ko, tr, pt-PT, de.
- [HIGH] Lazy-load locale bundles; cache after first load to avoid repeated fetch cost.
- [HIGH] Translate all user-facing strings: navigation, settings, dialogs, toasts/notifications, error surfaces, and backend-returned messages mapped via codes to frontend translations.

### Should Have (Medium Priority)
- [MEDIUM] Code-based errors/success codes from Rust commands mapped to frontend translations for consistency (avoid hardcoded English messages).
- [MEDIUM] Document how to add new locales (file path, key structure, registration).
- [MEDIUM] Ensure plugin initialization order does not delay app startup; measure/keep overhead minimal.

### Could Have (Low Priority / Inferred)
- [LOW] Fallback UI indicator when a translation key is missing (e.g., show key or English string) for debugging.
- [LOW] Tooling/checklist to verify coverage of required strings before release.

## Technical Constraints
- **Framework/Stack:** React 18 + TypeScript + Vite in Tauri 2.0.
- **Performance:** Runtime switching without restart; lazy-load locales to keep initial load fast; cache bundles post-load.
- **Scale:** Desktop app; no high concurrent load concerns.
- **Integrations:** `tauri-plugin-i18n`, `tauri-plugin-locale`; frontend config persistence (existing config file with dark mode).
- **Other:** Use codes from Rust layer mapped to translations to keep backend messages localized consistently.

## User Context
**Target Users:** FMMLoader app users on desktop (Tauri).  
**Primary Use Case:** App reflects system language on first run; users can manually switch languages in Settings; app persists choice.  
**User Flow:** Startup → locale detected (fallback English) → UI loads → user may open Settings to pick language → change applies immediately and persists; backend messages surface via translated strings.

## Edge Cases & Considerations
- Missing/unsupported locale → fallback to English; log for diagnostics.
- Locale switch with missing keys → show fallback (English or key) without crashing; consider dev-only warning.
- Config file missing language entry → initialize with system detection result or English default.
- Backend codes not mapped in frontend → display safe generic message and log missing code.

## Implicit Requirements
*Inferred from conversation context - please verify:*
- Testing: smoke test language detection and switching across supported locales; verify persistence across restarts.
- Developer experience: provide clear key naming conventions and folder structure for contributors adding translations.
> **Note:** These requirements were surfaced by analyzing conversation patterns.

## Success Criteria
How we know this is complete and working:
- ✓ App starts in detected locale when supported; otherwise English.
- ✓ Language switcher in Settings applies immediately without restart and persists across restarts via config file.
- ✓ All user-facing strings (UI + backend messages via codes) are localized for en, ko, tr, pt-PT, de.
- ✓ Lazy-load works: initial load remains fast; subsequent switches do not re-fetch already loaded locales.

## Next Steps
1. Review this PRD for accuracy and completeness
2. If anything is missing or unclear, continue the conversation
3. When ready, use the optimized prompt for implementation

---
*This PRD was generated by Clavix from conversational requirements gathering.*
